buildscript {
    dependencies {
        classpath("org.jfrog.buildinfo:build-info-extractor-gradle:${jfrogBuildExtractorVersion}")
    }
    repositories {
        mavenCentral()
        jcenter()
    }
}

plugins {
    id "org.jetbrains.kotlin.jvm" version "${kotlinVersion}"
    id "com.adarshr.test-logger" version "${testLoggerPluginVersion}" apply false
    id 'com.github.johnrengelman.shadow' version "${shadowPluginVersion}" apply false
    id "com.palantir.graal" version "${palantirGraalNativeVersion}" apply false
    id 'com.bmuschko.docker-remote-api' version "${bmuschkoDockerPluginVersion}" apply false
    id 'com.google.cloud.tools.jib' version "${jibPluginVersion}" apply false
}

apply plugin: 'idea'

subprojects {
    apply plugin: 'com.adarshr.test-logger'
    apply plugin: 'kotlin'

    group = "com.omarsmak.kafka.consumer.lag.monitoring"
    version = '0.1.3'

    ext {
        libraryName = "kafka-consumer-lag-monitoring"
        libraryVersion = version
    }

    idea {
        module {
            downloadJavadoc = true
            downloadSources = true
        }
    }

    compileKotlin {
        kotlinOptions.jvmTarget = "1.8"
    }

    compileTestKotlin {
        kotlinOptions.jvmTarget = "1.8"
    }

    test {
        useJUnitPlatform()
    }

    dependencies {
        compile "io.github.microutils:kotlin-logging:$kotlinLoggingVersion"

        testImplementation "org.junit.jupiter:junit-jupiter-api:${junitVersion}"
        testRuntimeOnly "org.junit.jupiter:junit-jupiter-engine:${junitVersion}"
        testCompile "org.jetbrains.kotlin:kotlin-test-junit:$kotlinVersion"
    }
}


import com.bmuschko.gradle.docker.tasks.image.Dockerfile
import com.bmuschko.gradle.docker.tasks.image.DockerBuildImage
import com.bmuschko.gradle.docker.tasks.image.DockerTagImage
import com.bmuschko.gradle.docker.tasks.image.DockerPushImage

// these tasks only applicable for any component
configure(subprojects.findAll { it.name.contains("component") }) {
    apply plugin: 'com.github.johnrengelman.shadow'
    apply plugin: 'com.palantir.graal'
    apply plugin: 'com.bmuschko.docker-remote-api'
    apply plugin: 'com.google.cloud.tools.jib'

    afterEvaluate {
        ext {
            componentFullName = libraryName + "-" + project.componentName
            componentFullNameWithVersion = componentFullName + "-" + version
            componentDockerName = "omarsmak/" + componentFullName
            componentDockerNativeName = componentDockerName + "-native"
         }

        shadowJar {
            zip64 = true
            archiveBaseName.set(componentFullName)
        }

        jar {
            manifest {
                attributes(
                        "Multi-Release": true
                )
            }
        }

        graal {
            graalVersion graalNativeImageVersion
            outputName componentFullNameWithVersion
            mainClass project.mainClassName
            javaVersion '11'
            option '--no-fallback'
            option '--report-unsupported-elements-at-runtime'
            option '--allow-incomplete-classpath'
        }

        docker {
            registryCredentials {
                username = System.getenv('DOCKERHUB_USER')
                password = System.getenv('DOCKERHUB_PASSWORD')
                email = 'omarsmak@gmail.com'
            }
        }

        jib {
            from.image 'gcr.io/distroless/java:11'
            to{
                image = componentDockerName
                tags = [libraryVersion, "latest"]
                auth {
                    username = System.getenv('DOCKERHUB_USER')
                    password = System.getenv('DOCKERHUB_PASSWORD')
                }
            }
            container {
                if (dockerExposedPort) {
                    ports = [dockerExposedPort.toString()]
                }

                jvmFlags = [
                        "-XX:+UseCompressedOops",
                        "-XX:MaxRAMPercentage=80",
                        "-Dfile.encoding=UTF-8",
                        "-Djava.security.egd=file:/dev/./urandom"
                ]
            }
        }

        task createNativeDockerfile(type: Dockerfile) {

            // First stage: build our native image inside a docker image

            from new Dockerfile.From("ghcr.io/graalvm/graalvm-ce:${graalNativeImageVersion}").withStage("build")
            workingDir "/app"
            copyFile componentFullName + "*all.jar", "/app/jar/application.jar"
            runCommand "gu install native-image"
            runCommand "native-image -jar jar/application.jar --no-fallback --report-unsupported-elements-at-runtime --allow-incomplete-classpath"

            // Second stage: Create our application docker image
            from "frolvlad/alpine-glibc"
            runCommand "apk update && apk add libstdc++"
            workingDir "/work/"
            copyFile new Dockerfile.CopyFile("/app/application", "/work/application").withStage("build")

            if (project.dockerExposedPort) {
                exposePort project.dockerExposedPort
            }

            entryPoint("./application")
        }

        task copyShadowJarToDockerContext(type: Copy) {
            dependsOn shadowJar

            from "$buildDir/libs"
            include componentFullName + "*all.jar"
            into "$buildDir/docker"
        }

        /**
         * Build a Docker image with native application
         */
        task buildNativeApplicationDockerImage(type: DockerBuildImage) {
            dependsOn copyShadowJarToDockerContext, createNativeDockerfile

            remove = true
            noCache = false
            images.add(componentDockerNativeName + ":latest")
            images.add(componentDockerNativeName + ":$version")
        }

        /**
         * Build and push a Docker image with native application
         */
        task buildAndPushNativeApplicationDockerImage(type: DockerPushImage) {
            dependsOn buildNativeApplicationDockerImage

            images.set(buildNativeApplicationDockerImage.images)
        }

        /**
         * Build a native application using Graal Native Image
         */
        task buildNativeApplication(type: Tar) {
            dependsOn nativeImage

            OperatingSystem os = org.gradle.nativeplatform.platform.internal.DefaultNativePlatform.currentOperatingSystem;

            def osName = "generic"

            if (os.linux) {
                osName = "linux"
            } else if (os.macOsX) {
                osName = "mac"
            } else if (os.windows) {
                osName = "windows"
            }

            archiveFileName = "$componentFullNameWithVersion-${osName}.tar.gz"
            destinationDirectory = file("$buildDir/dist")
            compression = Compression.GZIP

            from "$buildDir/graal/$componentFullNameWithVersion"
        }

        /**
         * Build a Docker image with jar application
         */
        task buildDockerImage {
            dependsOn jibDockerBuild
        }

        /**
         * Build and push a Docker image with jar application
         */
        task buildAndPushDockerImage {
            dependsOn jib
        }
    }
}

allprojects {
    repositories {
        mavenCentral()
        jcenter()
    }
}
